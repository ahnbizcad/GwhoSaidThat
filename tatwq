=> [31m[1;31m"[0m[31m:source-highlighter: coderay[1;35m\r[0m[31m[1;35m\n[0m[31m:coderay-css: class[1;35m\r[0m[31m[1;35m\n[0m[31m:coderay-linenums-mode: table[1;35m\r[0m[31m[1;35m\n[0m[31m[1;35m\r[0m[31m[1;35m\n[0m[31mIn ruby, what you might be familiar with as a class variable is actually a class instance variable. People will sometimes refer to them as [1;35m\"[0m[31mclass variables[1;35m\"[0m[31m as well, further confusing those new to ruby.[1;35m\r[0m[31m[1;35m\n[0m[31m[1;35m\r[0m[31m[1;35m\n[0m[31m[1;35m\\[0m[31mr[1;35m\\[0m[31mn[1;35m\r[0m[31m[1;35m\n[0m[31m[1;35m\r[0m[31m[1;35m\n[0m[31mActual class variables in ruby are shared with subclasses, and can thus get overwritten by the family of classes. You can think of them as global variables within the descendant subclasses and the class in which it was defined. Due to this behavior, usage of actual class variables is rare and generally frowned upon.[1;35m\r[0m[31m[1;35m\n[0m[31m[1;35m\r[0m[31m[1;35m\n[0m[31mBelow, the syntax for declaring class variables, instance variables, and class instance variables is listed[1;35m\r[0m[31m[1;35m\n[0m[31m[1;35m\r[0m[31m[1;35m\n[0m[31m[source,ruby,linenums][1;35m\r[0m[31m[1;35m\n[0m[31m.bird.rb[1;35m\r[0m[31m[1;35m\n[0m[31m----[1;35m\r[0m[31m[1;35m\n[0m[31m#class variable[1;35m\r[0m[31m[1;35m\n[0m[31m#specific to the class and all of its descendant subclasses.[1;35m\r[0m[31m[1;35m\n[0m[31m@@class_var[1;35m\r[0m[31m[1;35m\n[0m[31m[1;35m\r[0m[31m[1;35m\n[0m[31m#instance variable[1;35m\r[0m[31m[1;35m\n[0m[31m#specific to an instance of the class[1;35m\\[0m[31mr[1;35m\\[0m[31mn@instance_var[1;35m\\[0m[31mr[1;35m\\[0m[31mn[1;35m\\[0m[31mr[1;35m\\[0m[31mn#class instance variable[1;35m\\[0m[31mr[1;35m\\[0m[31mn#specific to the class[1;35m\\[0m[31mr[1;35m\\[0m[31mn@ci_var[1;35m\\[0m[31mr[1;35m\\[0m[31mnclass << self[1;35m\\[0m[31mr[1;35m\\[0m[31mn  attr_accessor :ci_var[1;35m\\[0m[31mr[1;35m\\[0m[31mnend[1;35m\\[0m[31mr[1;35m\\[0m[31mn----[1;35m\\[0m[31mr[1;35m\\[0m[31mn[1;35m\\[0m[31mr[1;35m\\[0m[31mnEach individual bird may will have different weights, so an instance variable, `@weight`, is appropriate. [1;35m\\[0m[31mr[1;35m\\[0m[31mn[1;35m\\[0m[31mr[1;35m\\[0m[31mnA type of bird, like chicken, will be a subclass of `bird.rb`, say `chicken.rb`. We want the `@color` property to be the same for a given subclass of bird, and different among the subclasses of birds. The class instance variable `@color will apply for all chickens. We would not want the color of `chicken.rb` to be linked and shared with the color for `penguin.rb`. [1;35m\\[0m[31mr[1;35m\\[0m[31mn[1;35m\\[0m[31mr[1;35m\\[0m[31mnWe do, however, want the count of all birds on planet earth to be shared and accessible among all subclasses of `bird.rb`. This is where class variables are good (but not quite, as we'll later see).[1;35m\\[0m[31mr[1;35m\\[0m[31mn[1;35m\\[0m[31mr[1;35m\\[0m[31mn## A review[1;35m\\[0m[31mr[1;35m\\[0m[31mn[1;35m\\[0m[31mr[1;35m\\[0m[31mn*Class variables* are defined by `@` characters before the variable name within a class, like so `@@my_variable`. Naturally, It is accessible by any descendant subclasses (or family, if you will) of the class in which it was defined. When any descendant subclass assigns a new value to the class variable, the value of the class variable changes for all classes with access to that variable. A class variable is like a global variable, except limited to the descendant subclasses of the class in which it was defined.[1;35m\\[0m[31mr[1;35m\\[0m[31mn[1;35m\\[0m[31mr[1;35m\\[0m[31mnClass variables are appropriate in cases where you want a variable shared across a family of classes. [1;35m\\[0m[31mr[1;35m\\[0m[31mn[1;35m\\[0m[31mr[1;35m\\[0m[31mn[source,ruby,linenums][1;35m\\[0m[31mr[1;35m\\[0m[31mn----[1;35m\\[0m[31mr[1;35m\\[0m[31mnexample[1;35m\\[0m[31mr[1;35m\\[0m[31mn----[1;35m\\[0m[31mr[1;35m\\[0m[31mn[1;35m\\[0m[31mr[1;35m\\[0m[31mnBut what if you need a variable that applies to a class, but without being re-writable by its subclasses? Well, the solution is to use *class instance variables*, which are simply plain old instance variables used in a clever way.[1;35m\\[0m[31mr[1;35m\\[0m[31mn[1;35m\\[0m[31mr[1;35m\\[0m[31mn[1;35m\\[0m[31mr[1;35m\\[0m[31mn[1;35m\\[0m[31mr[1;35m\\[0m[31mn[1;35m\\[0m[31mr[1;35m\\[0m[31mn[1;35m\\[0m[31mr[1;35m\\[0m[31mnClass variables are shared and available to its subclasses. This means a subclass reassigning a class variable doesn't create its own copy for that subclass, but rather, overwrites the value shared across the parent class, and any descendant subclasses of the class it was defined in. [1;35m\\[0m[31mr[1;35m\\[0m[31mn[1;35m\\[0m[31mr[1;35m\\[0m[31mnInstead of[1;35m\\[0m[31mr[1;35m\\[0m[31mn[1;35m\\[0m[31mr[1;35m\\[0m[31mn[source,ruby,linenums][1;35m\\[0m[31mr[1;35m\\[0m[31mn----[1;35m\\[0m[31mr[1;35m\\[0m[31mndef animal[1;35m\\[0m[31mr[1;35m\\[0m[31mn  @@legs = 20[1;35m\\[0m[31mr[1;35m\\[0m[31mnend[1;35m\\[0m[31mr[1;35m\\[0m[31mn----[1;35m\\[0m[31mr[1;35m\\[0m[31mn[1;35m\\[0m[31mr[1;35m\\[0m[31mndo [1;35m\\[0m[31mr[1;35m\\[0m[31mn[1;35m\\[0m[31mr[1;35m\\[0m[31mn[source,ruby,linenums][1;35m\\[0m[31mr[1;35m\\[0m[31mn----[1;35m\\[0m[31mr[1;35m\\[0m[31mndef animal[1;35m\\[0m[31mr[1;35m\\[0m[31mn  @@legs = 20[1;35m\\[0m[31mr[1;35m\\[0m[31mn  class << self[1;35m\\[0m[31mr[1;35m\\[0m[31mn    attr_accessor :legs[1;35m\\[0m[31mr[1;35m\\[0m[31mn  end[1;35m\\[0m[31mr[1;35m\\[0m[31mnend[1;35m\\[0m[31mr[1;35m\\[0m[31mn[1;35m\\[0m[31mr[1;35m\\[0m[31mndef dog < animal[1;35m\\[0m[31mr[1;35m\\[0m[31mn  @legs = 20[1;35m\\[0m[31mr[1;35m\\[0m[31mnend[1;35m\\[0m[31mr[1;35m\\[0m[31mn----[1;31m"[0m[31m[0m
